/*
    -----------------------------------------------------------------------------
    CSLiteScript is a fast easy Script Language for dotnetframework,Mono,Unity hot fix and everywhere
    This source file is part of CSLiteScript
    For the latest info, see https://github.com/RainsSoft/CSLiteScript/
    my blog:http://blog.csdn.net/andyhebear
  
   
    Copyright (c) 2014-2030 rains soft
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
    -----------------------------------------------------------------------------
    */
namespace CSLiteScript
{
    using System;

    public class Errors
    {
        public const string CS0001 = "CS0001. Internal compiler error.";
        public const string CS0003 = "CS0003. Out of memory.";
        public const string CS0004 = "CS0004. Warning treated as error.";
        public const string CS0005 = "CS0005. Compiler option '{0}' must be followed by an argument.";
        public const string CS0006 = "CS0006. Metadata file '{0}' could not be found.";
        public const string CS0007 = "CS0007. Unexpected common language runtime initialization error — '{0}'.";
        public const string CS0008 = "CS0008. Unexpected error reading metadata from file '{0}' — '{1}'.";
        public const string CS0009 = "CS0009. Metadata file '{0}' could not be opened — '{1}'.";
        public const string CS0010 = "CS0010. Cannot declare a namespace and a type both named '{0}'.";
        public const string CS0011 = "CS0011. Referenced class '{0}' has base class or interface '{1}' defined in an assembly that is not referenced. You must add a reference to assembly '{2}'.";
        public const string CS0012 = "CS0012. The type '{0}' is defined in an assembly that is not referenced. You must add a reference to assembly '{1}'.";
        public const string CS0013 = "CS0013. Unexpected error writing metadata to file '{0}' — '{1}'.";
        public const string CS0014 = "CS0014. Required file '{0}' could not be found.";
        public const string CS0015 = "CS0015. The name of type '{0}' is too long.";
        public const string CS0016 = "CS0016. Could not write to output file '{0}' — '{1}'.";
        public const string CS0017 = "CS0017. Program has more than one entry point defined.";
        public const string CS0019 = "CS0019. Operator '{0}' cannot be applied to operands of type '{1}' and '{2}'.";
        public const string CS0020 = "CS0020. Division by constant zero.";
        public const string CS0021 = "CS0021. Cannot apply indexing with [] to an expression of type '{0}'.";
        public const string CS0022 = "CS0022. Wrong number of indices inside [], expected '{0}'.";
        public const string CS0023 = "CS0023. Operator '{0}' cannot be applied to operand of type '{1}'.";
        public const string CS0025 = "CS0025. Standard library file '{0}' could not be found.";
        public const string CS0026 = "CS0026. Keyword this is not valid in a static property, static method, or static field initializer.";
        public const string CS0027 = "CS0027. Keyword this is not available in the current context.";
        public const string CS0028 = "CS0028. Function declaration has the wrong signature to be an entry point.";
        public const string CS0029 = "CS0029. Cannot impllicitly convert type '{0}' to '{1}'.";
        public const string CS0030 = "CS0030. Cannot convert type '{0}' to '{1}'.";
        public const string CS0031 = "CS0031. Constant value '{0}' cannot be converted to a '{1}'.";
        public const string CS0032 = "CS0032. Could not open incremental build file '{0}' for writing.";
        public const string CS0033 = "CS0033. Out of disk space or I/O error writing incremental build file '{0}'.";
        public const string CS0034 = "CS0034. Operator '{0}' is ambiguous on operands of type '{1}' and '{2}'.";
        public const string CS0035 = "CS0035. Operator '{0}' is ambiguous on an operand of type '{1}'.";
        public const string CS0036 = "CS0036. An out parameter cannot have the '[In]' attribute.";
        public const string CS0037 = "CS0037. Cannot convert null to '{0}' because it is a value type.";
        public const string CS0038 = "CS0038. Cannot access a nonstatic member of outer type '{0}' via nested type '{1}'.";
        public const string CS0039 = "CS0039. Cannot convert type '{0}' to '{1}'.";
        public const string CS0040 = "CS0040. Unexpected debug information initialization error — '{0}'";
        public const string CS0041 = "CS0041. Unexpected error writing debug information to file '{0}' — '{1}'.";
        public const string CS0042 = "CS0042. Unexpected error creating debug information file '{0}' — '{1}'.";
        public const string CS0043 = "CS0043. PDB file '{0}' has an incorrect or out-of-date format. Delete it and rebuild.";
        public const string CS0050 = "CS0050. Inconsistent accessibility: return type '{0}' is less accessible than method '{1}'.";
        public const string CS0051 = "CS0051. Inconsistent accessibility: parameter type '{0}' is less accessible than method '{1}'.";
        public const string CS0052 = "CS0052. Inconsistent accessibility: field type '{0}' is less accessible than field '{1}'.";
        public const string CS0053 = "CS0053. Inconsistent accessibility: property type '{0}' is less accessible than property '{1}'.";
        public const string CS0054 = "CS0054. Inconsistent accessibility: indexer return type '{0}' is less accessible than indexer '{1}'.";
        public const string CS0055 = "CS0055. Inconsistent accessibility: parameter type '{0}' is less accessible than indexer '{1}'.";
        public const string CS0056 = "CS0056. Inconsistent accessibility: return type '{0}' is less accessible than operator '{1}'.";
        public const string CS0057 = "CS0057. Inconsistent accessibility: parameter type '{0}' is less accessible than operator '{1}'.";
        public const string CS0058 = "CS0058. Inconsistent accessibility: parameter type '{0}' is less accessible than delegate '{1}'.";
        public const string CS0059 = "CS0059. Inconsistent accessibility: parameter type '{0}' is less accessible than delegate '{1}'.";
        public const string CS0060 = "CS0060. Inconsistent accessibility: base class '{0}' is less accessible than class '{1}'.";
        public const string CS0061 = "CS0061. Inconsistent accessibility: base interface '{0}' is less accessible than interface '{1}.'";
        public const string CS0065 = "CS0065. '{0}' : event property must have both add and remove accessors.";
        public const string CS0066 = "CS0066. '{0}': event must be of a delegate type.";
        public const string CS0067 = "CS0067. The event '{0}' is never used.";
        public const string CS0068 = "CS0068. '{0}': event in interface cannot have initializer.";
        public const string CS0069 = "CS0069. '{0}': event in interface cannot have add or remove accessors.";
        public const string CS0070 = "CS0070. The event 'event' can only appear on the left hand side of += or -= (except when used from within the type 'type').";
        public const string CS0071 = "CS0071. An explicit interface implementation of an event must use property syntax";
        public const string CS0072 = "CS0072. '{0}' : cannot override; '{1}' is not an event.";
        public const string CS0073 = "CS0073. An add or remove accessor must have a body.";
        public const string CS0074 = "CS0074. '{0}': abstract event cannot have initializer.";
        public const string CS0075 = "CS0075. To cast a negative value, you must enclose the value in parentheses.";
        public const string CS0076 = "CS0076. The enumerator name 'value__' is reserved and cannot be used.";
        public const string CS0077 = "CS0077. The as operator must be used with a reference type ('{0}' is a value type).";
        public const string CS0078 = "CS0077. The 'l' suffix is easily confused with the digit '1' -- use 'L' for clarity.";
        public const string CS0079 = "CS0079. The event '{0}' can only appear on the left hand side of += or -=.";
        public const string CS0100 = "CS0100. The parameter name '{0}' is a duplicate.";
        public const string CS0101 = "CS0101. The namespace '{0}' already contains a definition for '{1}'.";
        public const string CS0102 = "CS0102. The class '{0}' already contains a definition for '{1}'.";
        public const string CS0103 = "CS0103. The name '{0}' does not exist in the class or namespace '{1}'.";
        public const string CS0104 = "CS0104. '{0}' is an ambiguous reference.";
        public const string CS0105 = "CS0105. The using directive for '{0}' appeared previously in this namespace.";
        public const string CS0106 = "CS0106. The modifier '{0}' is not valid for this item.";
        public const string CS0107 = "CS0107. More than one protection modifier.";
        public const string CS0108 = "CS0108. The keyword new is required on '{0}' because it hides inherited member '{1}'";
        public const string CS0109 = "CS0109. The member '{0}' does not hide an inherited member. The new keyword is not required.";
        public const string CS0110 = "CS0110. The evaluation of the constant value for '{0}' involves a circular definition.";
        public const string CS0111 = "CS0111. Class '{0}' already defines a member called '{1}' with the same parameter types.";
        public const string CS0112 = "CS0112. A static member '{0}' cannot be marked as override, virtual or abstract.";
        public const string CS0113 = "CS0113. A member '{0}' marked as override cannot be marked as new or virtual.";
        public const string CS0114 = "CS0114. '{0}' hides inherited member '{1}'. To make the current method override that implementation, add the override keyword. Otherwise add the new keyword.";
        public const string CS0115 = "CS0115. '{0}' : no suitable method found to override.";
        public const string CS0116 = "CS0116. A namespace does not directly contain members such as fields or methods.";
        public const string CS0117 = "CS0117. '{0}' does not contain a definition for '{1}'.";
        public const string CS0118 = "CS0118. '{0}' denotes a '{1}' where a '{2}' was expected.";
        public const string CS0119 = "CS0119. '{0}' denotes a '{1}' which is not valid in the given context.";
        public const string CS0120 = "CS0120. An object reference is required for the nonstatic field, method, or property '{0}'.";
        public const string CS0121 = "CS0121. The call is ambiguous between the following methods or properties: '{0}' and '{1}'.";
        public const string CS0122 = "CS0122. '{0}' is inaccessible due to its protection level.";
        public const string CS0123 = "CS0123. Method '{0}' does not match delegate '{1}'.";
        public const string CS0126 = "CS0126. An object of a type convertible to '{0}' required.";
        public const string CS0127 = "CS0127. Since '{0}' returns void, a return keyword must not be followed by an object expression.";
        public const string CS0128 = "CS0128. A local variable named '{0}' is already defined in this scope.";
        public const string CS0131 = "CS0131. The left-hand side of an assignment must be a variable, property or indexer.";
        public const string CS0132 = "CS0132. '{0}' : a static constructor must be parameterless.";
        public const string CS0133 = "CS0133. The expression being assigned to '{0}' must be constant.";
        public const string CS0134 = "CS0134. Cannot use qualified namespace names in nested namespace declarations.";
        public const string CS0135 = "CS0135. '{0}' conflicts with the declaration '{1}'";
        public const string CS0136 = "CS0136. A local variable named '{0}' cannot be declared in this scope because it would give a different meaning to '{0}', which is already used in a '{1}' scope to denote something else";
        public const string CS0138 = "CS0138. A using namespace directive can only be applied to namespaces; '{0}' is a class not a namespace.";
        public const string CS0139 = "CS0139. No enclosing loop out of which to break or continue.";
        public const string CS0140 = "CS0140. The label '{0}' is a duplicate.";
        public const string CS0143 = "CS0143. The type '{0}' has no constructors defined.";
        public const string CS0144 = "CS0144. Cannot create an instance of the abstract class or interface '{0}'.";
        public const string CS0145 = "CS0145. A const field requires a value to be provided.";
        public const string CS0146 = "CS0146. Circular base class definition between '{0}' and '{1}'.";
        public const string CS0148 = "CS0148. The delegate '{0}' does not have a valid constructor.";
        public const string CS0149 = "CS0149. Method name expected.";
        public const string CS0150 = "CS0150. A constant value is expected.";
        public const string CS0151 = "CS0151. A value of an integral type expected.";
        public const string CS0152 = "CS0152. The label '{0}' already occurs in this switch statement.";
        public const string CS0153 = "CS0153. A goto case is only valid inside a switch statement.";
        public const string CS0154 = "CS0154. The property or indexer '{0}' cannot be used in this context because it lacks the get accessor.";
        public const string CS0155 = "CS0155. The type caught or thrown must be derived from System.Exception.";
        public const string CS0156 = "CS0156. A throw statement with no arguments is not allowed outside of a catch clause.";
        public const string CS0157 = "CS0157. Control cannot leave the body of a finally clause.";
        public const string CS0158 = "CS0158. The label '{0}' shadows another label by the same name in a contained scope.";
        public const string CS0159 = "CS0159. No such label '{0}' within the scope of the goto statement.";
        public const string CS0160 = "CS0160. A previous catch clause already catches all exceptions of this or a super type ('{0}').";
        public const string CS0161 = "CS0161. '{0}': not all code paths return a value.";
        public const string CS0162 = "CS0162. Unreachable code detected.";
        public const string CS0163 = "CS0163. Control cannot fall through from one case label ('{0}') to another.";
        public const string CS0164 = "CS0164. This label has not been referenced.";
        public const string CS0165 = "CS0165. Use of unassigned local variable '{0}'.";
        public const string CS0167 = "CS0167. The delegate '{0}' is missing the Invoke method.";
        public const string CS0168 = "CS0168. The variable '{0}' is declared but never used.";
        public const string CS0169 = "CS0169. The private field '{0}' is never used.";
        public const string CS0170 = "CS0170. Use of possibly unassigned field '{0}'.";
        public const string CS0171 = "CS0171. Field '{0}' must be fully assigned before control leaves the constructor.";
        public const string CS0172 = "CS0172. Type of conditional expression can't be determined because '{0}' and '{1}' both implicitly convert to each other.";
        public const string CS0173 = "CS0173. Type of conditional expression can't be determined because there is no implicit conversion between '{0}' and '{1}'.";
        public const string CS0174 = "CS0174. A base class is required for a base reference.";
        public const string CS0175 = "CS0175. Use of keyword base is not valid in this context.";
        public const string CS0176 = "CS0176. Static member '{0}' cannot be accessed with an instance reference; qualify it with a type name instead.";
        public const string CS0177 = "CS0177. The out parameter '{0}' must be assigned to before control leaves the current method.";
        public const string CS0178 = "CS0178. Incorrectly structured array initializer.";
        public const string CS0179 = "CS0179. '{0}' cannot be extern and declare a body.";
        public const string CS0180 = "CS0180. '{0}' cannot be both extern and abstract.";
        public const string CS0182 = "CS0182. An attribute argument must be a constant expression, typeof expression or array creation expression.";
        public const string CS0183 = "CS0183. The given expression is always of the provided ('{0}') type.";
        public const string CS0184 = "CS0184. The given expression is never of the provided ('{0}') type.";
        public const string CS0185 = "CS0185. '{0}' is not a reference type as required by the lock statement.";
        public const string CS0186 = "CS0186. Use of null is not valid in this context.";
        public const string CS0187 = "CS0187. No such operator '{0}' defined for type '{1}'.";
        public const string CS0188 = "CS0188. The this object cannot be used before all of its fields are assigned to.";
        public const string CS0191 = "CS0191. A readonly field cannot be assigned to (except in a constructor or a variable initializer).";
        public const string CS0192 = "CS0192. A readonly field cannot be passed ref or out (except in a constructor).";
        public const string CS0193 = "CS0193. The * or -> operator must be applied to a pointer.";
        public const string CS0196 = "CS0196. A pointer must be indexed by only one value.";
        public const string CS0197 = "CS0197. Cannot pass '{0}' as ref or out, because ' argument ' is a marshal-by-reference class.";
        public const string CS0198 = "CS0198. A static readonly field cannot be assigned to (except in a static constructor or a variable initializer).";
        public const string CS0199 = "CS0199. A static readonly field cannot be passed ref or out (except in a static constructor).";
        public const string CS0200 = "CS0200. Property or indexer '{0}' cannot be assigned to — it is read only.";
        public const string CS0201 = "CS0201. Only assignment, call, increment, decrement, and new object expressions can be used as a statement.";
        public const string CS0202 = "CS0202. The call to GetEnumerator must return a class or a struct, not '{0}'";
        public const string CS0204 = "CS0204. Only 65535 locals are allowed.";
        public const string CS0205 = "CS0205. Cannot call an abstract base member: '{0}'.";
        public const string CS0206 = "CS0206. A property or indexer may not be passed as an out or ref parameter.";
        public const string CS0208 = "CS0208. Cannot take the address or size of a variable of a managed type ('S').";
        public const string CS0209 = "CS0209. The type of locals declared in a fixed statement must be a pointer type.";
        public const string CS0210 = "CS0210. You must provide an initializer in a fixed or using statement declaration.";
        public const string CS0211 = "CS0211. Cannot take the address of the given expression.";
        public const string CS0212 = "CS0212. You can only take the address of unfixed expression inside of a fixed statement initializer.";
        public const string CS0213 = "CS0213. You do not need to use the fixed statement to take the address of an already fixed expression.";
        public const string CS0214 = "CS0214. Pointers may only be used in an unsafe context.";
        public const string CS0215 = "CS0215. The return type of operator True or False must be bool.";
        public const string CS0216 = "CS0216. The operator '{0}' requires a matching operator '{1}' to also be defined.";
        public const string CS0217 = "CS0217. In order to be applicable as a short circuit operator a user-defined logical operator ('{0}') must have the same return type as the type of its 2 parameters.";
        public const string CS0218 = "CS0218. The type ('{0}') must contain declarations of operator true and operator false.";
        public const string CS0219 = "CS0219. The variable '{0}' is assigned but its value is never used.";
        public const string CS0220 = "CS0220. The operation overflows at compile time in checked mode.";
        public const string CS0221 = "CS0221. Constant value '{0}' cannot be converted to a '{1}' (use 'unchecked' syntax to override).";
        public const string CS0225 = "CS0225. The params parameter must be a single dimensional array.";
        public const string CS0227 = "CS0227. Unsafe code may only appear if compiling with /unsafe.";
        public const string CS0228 = "CS0228. '{0}' does not contain a definition for '{1}', or it is not accessible.";
        public const string CS0229 = "CS0229. Ambiguity between '{0}' and '{1}'";
        public const string CS0230 = "CS0230. Type and identifier are both required in a foreach statement.";
        public const string CS0231 = "CS0231. A params parameter must be the last parameter in a formal parameter list.";
        public const string CS0233 = "CS0233. sizeof can only be used in an unsafe context (consider using System.Runtime.InteropServices.Marshal.SizeOf).";
        public const string CS0234 = "CS0234. The type or namespace name '{0}' does not exist in the class or namespace '{1}' (are you missing an assembly reference?).";
        public const string CS0236 = "CS0236. A field initializer cannot reference the nonstatic field, method, or property '{0}'";
        public const string CS0238 = "CS0238. '{0}' cannot be sealed because it is not an override.";
        public const string CS0239 = "CS0239. '{0}' : cannot override inherited member '{1}' because it is sealed.";
        public const string CS0241 = "CS0241. Default parameter specifiers are not permitted.";
        public const string CS0242 = "CS0242. The operation in question is undefined on void pointers.";
        public const string CS0243 = "CS0243. Conditional not valid on 'method' because it is an override method.";
        public const string CS0244 = "CS0244. 'is' or 'as' are not valid on pointer types.";
        public const string CS0245 = "CS0245. Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available.";
        public const string CS0246 = "CS0246. The type or namespace name '{0}' could not be found (are you missing a using directive or an assembly reference?).";
        public const string CS0247 = "CS0247. Cannot use a negative size with stackalloc.";
        public const string CS0248 = "CS0248. Cannot create an array with a negative size.";
        public const string CS0249 = "CS0249. Do not override object.Finalize. Instead, provide a destructor.";
        public const string CS0250 = "CS0250. Do not directly call your base class Finalize method. It is called automatically from your destructor.";
        public const string CS0251 = "CS0251. Indexing an array with a negative index (array indices always start at zero).";
        public const string CS0252 = "CS0252. Possible unintended reference comparison; to get a value comparison, cast the left hand side to type '{0}'";
        public const string CS0253 = "CS0253. Possible unintended reference comparison; to get a value comparison, cast the right hand side to type '{0}'";
        public const string CS0254 = "CS0254. The right hand side of a fixed statement assignment may not be a cast expression.";
        public const string CS0255 = "CS0255. stackalloc may not be used in a catch or finally block.";
        public const string CS0500 = "CS0500. '{0}' cannot declare a body because it is marked abstract.";
        public const string CS0501 = "CS0501. '{0}' must declare a body because it is not marked abstract or extern.";
        public const string CS0502 = "CS0502. The class '{0}' is abstract and sealed.";
        public const string CS0503 = "CS0503. The abstract method '{0}' cannot be marked virtual.";
        public const string CS0504 = "CS0504. The constant '{0}' cannot be marked static.";
        public const string CS0505 = "CS0505. '{0}' : cannot override; '{1}' is not a function.";
        public const string CS0506 = "CS0506. '{0}' : cannot override inherited member '{1}' because it is not marked 'virtual', 'abstract', or 'override'.";
        public const string CS0507 = "CS0507. '{0}' : cannot change access modifiers when overriding '{1}' inherited member '{2}'.";
        public const string CS0508 = "CS0508. '{0}' cannot change return type when overriding inherited member '{1}'.";
        public const string CS0509 = "CS0509. '{0}' : cannot inherit from sealed class '{1}'.";
        public const string CS0513 = "CS0513. '{0}' is abstract but it is contained in nonabstract class '{1}'";
        public const string CS0514 = "CS0514. '{0}' : static constructor cannot have an explicit this or base constructor call.";
        public const string CS0515 = "CS0515. '{0}' : access modifiers are not allowed on static constructors.";
        public const string CS0516 = "CS0516. Constructor '{0}' can not call itself.";
        public const string CS0517 = "CS0517. '{0}' has no base class and cannot call a base constructor.";
        public const string CS0518 = "CS0518. The predefined type '{0}' is not defined or imported.";
        public const string CS0519 = "CS0519. '{0}' conflicts with a predefined namespace.";
        public const string CS0520 = "CS0520. '{0}' conflicts with a predefined type.";
        public const string CS0522 = "CS0522. '{0}' : structs cannot call base class constructors.";
        public const string CS0523 = "CS0523. Struct member '{0}' of type '{1}' causes a cycle in the structure layout.";
        public const string CS0524 = "CS0524. '{0}' : interfaces cannot declare types.";
        public const string CS0525 = "CS0525. Interfaces cannot contain fields.";
        public const string CS0526 = "CS0526. Interfaces cannot contain constructors.";
        public const string CS0527 = "CS0527. '{0}' : type in interface list is not an interface.";
        public const string CS0528 = "CS0528. '{0}' is already listed in interface list.";
        public const string CS0529 = "CS0529. Inherited interface '{0}' causes a cycle in the interface hierarchy of '{1}'.";
        public const string CS0531 = "CS0531. '{0}' : interface members cannot have a definition.";
        public const string CS0533 = "CS0533. '{0}' hides inherited abstract member '{1}'.";
        public const string CS0534 = "CS0534. '{0}' does not implement inherited abstract member '{1}'.";
        public const string CS0535 = "CS0535. '{0}' does not implement interface member '{1}'.";
        public const string CS0536 = "CS0536. '{0}' does not implement interface member '{1}'. '{2}' is either static, not public, or has the wrong return type.";
        public const string CS0537 = "CS0537. The class System.Object cannot have a base class or implement an interface.";
        public const string CS0538 = "CS0538. '{0}' in explicit interface declaration is not an interface.";
        public const string CS0539 = "CS0539. '{0}' in explicit interface declaration is not a member of interface.";
        public const string CS0540 = "CS0540. '{0}' : containing class does not implement interface '{1}'";
        public const string CS0541 = "CS0541. '{0}' : explicit interface declaration can only be declared in a class or struct.";
        public const string CS0542 = "CS0542. '{0}' : member names cannot be the same as their enclosing type.";
        public const string CS0543 = "CS0543. '{0}' : the enumerator value is too large to fit in its type.";
        public const string CS0544 = "CS0544. '{0}' : cannot override; '{1}' is not a property.";
        public const string CS0545 = "CS0545. '{0}' : cannot override because '{1}' does not have an overridable get accessor.";
        public const string CS0546 = "CS0546. '{0}' : cannot override because '{1}' does not have an overridable set accessor.";
        public const string CS0547 = "CS0547. '{0}' : property or indexer cannot have void type.";
        public const string CS0548 = "CS0548. '{0}' : property or indexer must have at least one accessor.";
        public const string CS0549 = "CS0549. '{0}' is a new virtual member in sealed class '{1}'.";
        public const string CS0550 = "CS0550. '{0}' adds an accessor not found in interface member '{1}'.";
        public const string CS0551 = "CS0551. Explicit interface implementation '{0}' is missing accessor '{1}'.";
        public const string CS0552 = "CS0552. '{0}' : user defined conversion to/from interface.";
        public const string CS0553 = "CS0553. '{0}' : user defined conversion to/from base class.";
        public const string CS0554 = "CS0554. '{0}' : user defined conversion to/from derived class.";
        public const string CS0555 = "CS0555. User-defined operator cannot take an object of the enclosing type and convert to an object of the enclosing type.";
        public const string CS0556 = "CS0556. User-defined conversion must convert to or from the enclosing type.";
        public const string CS0557 = "CS0557. Duplicate user-defined conversion in class '{0}'.";
        public const string CS0558 = "CS0558. User-defined operator 'operator' must be declared static and public.";
        public const string CS0559 = "CS0558. The parameter and return type for ++ or — operator must be the containing type.";
        public const string CS0560 = "CS0560. Accessor '{0}' : cannot override '{1}' because it is hidden by '{2}'.";
        public const string CS0561 = "CS0561. '{0}' : cannot override '{1}' because it is a special compiler-generated method.";
        public const string CS0562 = "CS0562. The parameter of a unary operator must be the containing type.";
        public const string CS0563 = "CS0563. One of the parameters of a binary operator must be the containing type.";
        public const string CS0564 = "CS0564. Overloaded shift operator must have the type of the first operand be the containing type, and the type of the second operand must be int.";
        public const string CS0567 = "CS0567. Interfaces cannot contain operators.";
        public const string CS0568 = "CS0568. Structs cannot contain explicit parameterless constructors.";
        public const string CS0569 = "CS0569. '{0}' : cannot override '{1}' because it is not supported by the language.";
        public const string CS0570 = "CS0570. '{0}' references a type not unsupported by the language.";
        public const string CS0571 = "CS0571. '{0}' : cannot explicitly call operator or accessor.";
        public const string CS0572 = "CS0572. '{0}' : cannot reference a type through an expression; try '{0}' instead.";
        public const string CS0573 = "CS0573. '{0}' : cannot have instance field initializers in structs.";
        public const string CS0574 = "CS0574. Name of destructor must match name of class.";
        public const string CS0575 = "CS0575. Only class types can contain destructors.";
        public const string CS0576 = "CS0576. Namespace '' already contains a definition for 'System'";
        public const string CS0577 = "CS0577. Conditional not valid on 'function' because it is a constructor, destructor, operator, or explicit interface implementation.";
        public const string CS0578 = "CS0578. Conditional not valid on 'function' because its return type is not void.";
        public const string CS0579 = "CS0579. Duplicate '{0}' attribute.";
        public const string CS0580 = "CS0580. Too many unnamed arguments to attribute '{0}'.";
        public const string CS0581 = "CS0581. Named arguments not allowed on attribute '{0}'";
        public const string CS0582 = "CS0582. Conditional not valid on interface members.";
        public const string CS0583 = "CS0583. Internal Compiler Error: likely culprit is '{0}'.";
        public const string CS0584 = "CS0584. Internal Compiler Error: stage '{0}' symbol '{1}'.";
        public const string CS0585 = "CS0585. Internal Compiler Error: stage '{0}'.";
        public const string CS0586 = "CS0586. Internal Compiler Error: stage '{0}'.";
        public const string CS0587 = "CS0587. Internal Compiler Error: stage '{0}'.";
        public const string CS0588 = "CS0588. Internal Compiler Error: stage 'LEX'.";
        public const string CS0589 = "CS0589. Internal Compiler Error: stage 'PARSE'.";
        public const string CS0590 = "CS0590. User-defined operators cannot return void.";
        public const string CS0591 = "CS0591. Invalid value for argument to '{0}' attribute.";
        public const string CS0592 = "CS0592. Attribute '{0}' is not valid on this declaration type. It is valid on '{1}' declarations only.";
        public const string CS0594 = "CS0594. Floating-point constant is outside the range of type '{0}'.";
        public const string CS0596 = "CS0596. The Guid attribute must be specified with the ComImport attribute.";
        public const string CS0597 = "CS0597. Too few unnamed arguments for attribute '{0}'.";
        public const string CS0599 = "CS0599. Invalid value for named attribute argument '{0}'.";
        public const string CS0601 = "CS0601. The DllImport attribute must be specified on a method marked 'static' and 'extern'.";
        public const string CS0602 = "CS0602. The feature '{0}' is deprecated. Please use '{1}' instead.";
        public const string CS0609 = "CS0609. Cannot set the name attribute on an indexer marked override.";
        public const string CS0610 = "CS0610. Field or property cannot be of type '{0}'.";
        public const string CS0611 = "CS0611. Array elements cannot be of type '{0}'.";
        public const string CS0612 = "CS0612. '{0}' is obsolete.";
        public const string CS0613 = "CS0613. '{0}': is not an attribute class.";
        public const string CS0617 = "CS0617. '{0}' is not a valid named attribute argument. Named attribute arguments must be fields which are not readonly, static or const, or read-write properties which are not static.";
        public const string CS0618 = "CS0618. '{0}' is obsolete: '{1}'.";
        public const string CS0619 = "CS0619. '{0}' is obsolete: '{1}'.";
        public const string CS0620 = "CS0620. Indexers can't have void type.";
        public const string CS0621 = "CS0621. Virtual or abstract members cannot be private.";
        public const string CS0622 = "CS0622. Can only use array initializer expressions to assign to array types. Try using a new expression instead.";
        public const string CS0623 = "CS0623. Array initializers can only be used in a variable or field initializer. Try using a new expression instead.";
        public const string CS0625 = "CS0625. '{0}' : Instance field types marked with StructLayout(LayoutKind.Explicit) must have a FieldOffset attribute.";
        public const string CS0626 = "CS0626. Method, operator, or accessor '{0}' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation.";
        public const string CS0628 = "CS0628. '{0}' : new protected member declared in sealed class.";
        public const string CS0629 = "CS0629. Conditional member '{0}' cannot implement interface member '{1}'.";
        public const string CS0631 = "CS0631. Indexers can't have ref or out parameters.";
        public const string CS0633 = "CS0633. The argument to the IndexerName attribute must be a valid identifier.";
        public const string CS0634 = "CS0634. '{0}' : argument only valid for marshal of type System.Interop.UnmanagedType.CustomMarshaller.";
        public const string CS0635 = "CS0635. '{0}' : System.Interop.UnmanagedType.CustomMarshaller requires named arguments ComType and Marshal.";
        public const string CS0636 = "CS0636. The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit).";
        public const string CS0637 = "CS0637. The FieldOffset attribute not allowed on static or const fields.";
        public const string CS0641 = "CS0641. '{0}' : attribute is only valid on classes derived from System.Attribute.";
        public const string CS0642 = "CS0642. Possible mistaken null statement.";
        public const string CS0643 = "CS0643. '{0}' duplicate named attribute argument.";
        public const string CS0644 = "CS0644. '{0}' cannot inherit from special class '{1}'";
        public const string CS0645 = "CS0645. Identifier too long.";
        public const string CS0646 = "CS0646. Cannot specify the DefaultMember attribute on type containing an indexer.";
        public const string CS0647 = "CS0647. Error emitting '{0}' attribute -- '{1}'.";
        public const string CS0648 = "CS0648. '{0}' is a type not supported by the language.";
        public const string CS0649 = "CS0649. Field '{0}' is never assigned to, and will always have its default value '{1}'.";
        public const string CS0650 = "CS0650. Syntax error, bad array declarator. To declare a managed array the rank specifier precedes the variable's identifier.";
        public const string CS0652 = "CS0652. Comparison to integral constant is useless; the constant is outside the range of type '{0}'.";
        public const string CS0653 = "CS0653. Cannot apply attribute class '{0}' because it is abstract.";
        public const string CS0654 = "CS0654. Method '{0}' referenced without parentheses.";
        public const string CS0655 = "CS0655. '{0}' is not a valid named attribute argument because it is not a valid attribute parameter type.";
        public const string CS0656 = "CS0656. Missing compiler required member 'object.member'.";
        public const string CS0657 = "CS0657. '{0}' is not a valid attribute location for this declaration. Valid attribute locations for this declaration are '{1}'.";
        public const string CS0658 = "CS0658. '{0}' is not a recognized attribute location. All attributes in this block will be ignored.";
        public const string CS0659 = "CS0659. '{0}' overrides Object.Equals(object o) but does not override Object.GetHashCode().";
        public const string CS0660 = "CS0660. '{0}' defines operator == or operator != but does not override Object.Equals(object o).";
        public const string CS0661 = "CS0661. '{0}' defines operator == or operator != but does not override Object.GetHashCode().";
        public const string CS0662 = "CS0662. '{0}' cannot specify only Out attribute on a ref parameter. Use both In and Out attributes, or neither.";
        public const string CS0663 = "CS0663. '{0}' cannot define overloaded methods which differ only on ref and out.";
        public const string CS0664 = "CS0664. Literal of type double cannot be implicitly converted to type '{0}'; use an '{1}' suffix to create a literal of this type.";
        public const string CS0665 = "CS0665. Assignment in conditional expression is always constant; did you mean to use == instead of = ?";
        public const string CS0666 = "CS0666. '{0}' : new protected member declared in struct.";
        public const string CS0667 = "CS0667. The feature 'MarshalAs attribute on method' is deprecated. Please use 'return : location override with MarshalAs attribute' instead'.";
        public const string CS0668 = "CS0668. Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type.";
        public const string CS0669 = "CS0669. A class with the ComImport attribute cannot have a user-defined constructor.";
        public const string CS0670 = "CS0670. Field cannot have void type.";
        public const string CS0672 = "CS0672. Member '{0}' overrides obsolete member '{1}'. Add the Obsolete attribute to '{0}'.";
        public const string CS0673 = "CS0673. System.Void cannot be used from C# -- use typeof(void) to get the void type object.";
        public const string CS0674 = "CS0674. Do not use 'System.ParamArrayAttribute'. Use the 'params' keyword instead.";
        public const string CS0675 = "CS0675. Bitwise-or operator used on a sign-extended operand; consider casting to a smaller unsigned type first.";
        public const string CS0676 = "CS0676. Cannot pass volatile field '{0}' as ref or out, or take its address.";
        public const string CS0677 = "CS0677. '{0}': a volatile field can not be of the type '{1}'.";
        public const string CS0678 = "CS0678. '{0}': a field can not be both volatile and readonly.";
        public const string CS0682 = "CS0682. '{0}' cannot implement '{1}' because it is not supported by the language.";
        public const string CS0683 = "CS0683. '{0}' explicit method implementation cannot implement '{1}' because it is an accessor.";
        public const string CS0684 = "CS0684. '{0}' interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'.";
        public const string CS0688 = "CS0688. '{0}' (a method, property accessor, or event accessor) has a link demand, but overrides or implements '{1}' (a method, property accessor, or event accessor) which does not have a link demand. A security hole may exist.";
        public const string CS0690 = "CS0690. Input file '{0}' is not a valid PE because it contains invalid metadata.";
        public const string CS1001 = "CS1001. Identifier expected.";
        public const string CS1002 = "CS1002. ; expected.";
        public const string CS1003 = "CS1003. Syntax error, '{0}' expected.";
        public const string CS1004 = "CS1004. Duplicate '{0}' modifier.";
        public const string CS1005 = "CS1005. Indirection to managed type is not valid.";
        public const string CS1007 = "CS1007. Property accessor already defined.";
        public const string CS1008 = "CS1008. Type byte, sbyte, short, ushort, int, uint, long, or ulong expected.";
        public const string CS1009 = "CS1009. Unrecognized escape sequence.";
        public const string CS1010 = "CS1010. Newline in constant.";
        public const string CS1011 = "CS1011. Empty character literal.";
        public const string CS1012 = "CS1012. Too many characters in character literal.";
        public const string CS1013 = "CS1013. Invalid number.";
        public const string CS1014 = "CS1014. A get or set accessor expected.";
        public const string CS1015 = "CS1015. An object, string, or class type expected.";
        public const string CS1016 = "CS1016. Named attribute argument expected.";
        public const string CS1017 = "CS1017. Try statement already has an empty catch block.";
        public const string CS1018 = "CS1018. Keyword this or base expected.";
        public const string CS1019 = "CS1019. Overloadable unary operator expected.";
        public const string CS1020 = "CS1020. Overloadable binary operator expected.";
        public const string CS1021 = "CS1021. Integral constant is too large.";
        public const string CS1022 = "CS1022. Type or namespace definition, or end-of-file expected.";
        public const string CS1023 = "CS1023. Embedded statement cannot be a declaration or labeled statement.";
        public const string CS1024 = "CS1024. Preprocessor directive expected.";
        public const string CS1025 = "CS1025. Single-line comment or end-of-line expected.";
        public const string CS1026 = "CS1026. ) expected.";
        public const string CS1027 = "CS1027. #endif directive expected.";
        public const string CS1028 = "CS1028. Unexpected preprocessor directive.";
        public const string CS1029 = "CS1029. #error: '{0}'.";
        public const string CS1030 = "CS1030. #warning: '{0}'.";
        public const string CS1031 = "CS1031. Type expected.";
        public const string CS1032 = "CS1032. Cannot define/undefine preprocessor symbols after first token in file.";
        public const string CS1033 = "CS1033. Compiler limit exceeded: File cannot exceed '{0}' lines.";
        public const string CS1034 = "CS1034. Compiler limit exceeded: Line cannot exceed '{0}' characters.";
        public const string CS1035 = "CS1035. End-of-file found, '*/' expected.";
        public const string CS1036 = "CS1036. ( or . expected.";
        public const string CS1037 = "CS1037. Overloadable operator expected.";
        public const string CS1038 = "CS1038. #endregion directive expected.";
        public const string CS1039 = "CS1039. Unterminated string literal.";
        public const string CS1040 = "CS1040. Preprocessor directives must appear as the first non-whitespace character on a line.";
        public const string CS1041 = "CS1041. Identifier expected, '{0}' is a keyword.";
        public const string CS1043 = "CS1043. { or ; expected.";
        public const string CS1044 = "CS1044. Cannot use more than one type in a for, using, fixed, or declaration statement.";
        public const string CS1055 = "CS1055. An add or remove accessor expected.";
        public const string CS1501 = "CS1501. No overload for method '{0}' takes '{1}' arguments.";
        public const string CS1502 = "CS1502. The best overloaded method match for '{0}' has some invalid arguments.";
        public const string CS1503 = "CS1503. Argument '{0}': cannot convert from '{1}' to '{2}'.";
        public const string CS1504 = "CS1504. Source file '{0}' could not be opened ('{1}').";
        public const string CS1507 = "CS1507. Cannot link resource file '{0}' when building a module.";
        public const string CS1508 = "CS1508. Resource identifier '{0}' has already been used in this assembly.";
        public const string CS1509 = "CS1509. Referenced file '{0}' is not an assembly; use '/addmodule' option instead.";
        public const string CS1510 = "CS1510. A ref or out argument must be an lvalue.";
        public const string CS1511 = "CS1511. Keyword base is not available in a static method.";
        public const string CS1512 = "CS1512. Keyword base is not available in the current context.";
        public const string CS1513 = "CS1513. } expected.";
        public const string CS1514 = "CS1514. { expected.";
        public const string CS1515 = "CS1515. 'in' is expected.";
        public const string CS1517 = "CS1517. Invalid preprocessor expression.";
        public const string CS1518 = "CS1518. Expected class, delegate, enum, interface, struct, or namespace.";
        public const string CS1519 = "CS1519. Invalid token '{0}' in class, struct, or interface member declaration.";
        public const string CS1520 = "CS1520. Class, struct, or interface method must have a return type.";
        public const string CS1521 = "CS1521. Invalid base type.";
        public const string CS1522 = "CS1522. Empty switch block.";
        public const string CS1523 = "CS1523. The keyword case or default must precede code in switch block.";
        public const string CS1524 = "CS1524. Expected catch or finally.";
        public const string CS1525 = "CS1525. Invalid expression term '{0}'.";
        public const string CS1526 = "CS1526. 'new' expression requires () or [] after type.";
        public const string CS1527 = "CS1527. Namespace elements cannot be explicitly declared as private, protected, or protected internal.";
        public const string CS1528 = "CS1528. Expected ; or = (cannot specify constructor arguments in declaration).";
        public const string CS1529 = "CS1529. A using clause must precede all other namespace elements.";
        public const string CS1530 = "CS1530. Keyword new not allowed on namespace elements.";
        public const string CS1533 = "CS1533. Invoke cannot be called directly on a delegate.";
        public const string CS1534 = "CS1534. Overloaded binary operator '{0}' only takes two parameters.";
        public const string CS1535 = "CS1535. Overloaded unary operator '{0}' only takes one parameter.";
        public const string CS1536 = "CS1536. Invalid parameter type void.";
        public const string CS1537 = "CS1537. The using alias 'alias' appeared previously in this namespace.";
        public const string CS1540 = "CS1540. Cannot access protected member '{0}' via a qualifier of type '{1}'; the qualifier must be of type '{2}' (or derived from it).";
        public const string CS1541 = "CS1541. Invalid include option: '{0}' — cannot include directories.";
        public const string CS1542 = "CS1542. 'dll' cannot be added to this assembly because it already is an assembly; use '/R' option instead.";
        public const string CS1545 = "CS1545. Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor methods 'set accessor' or 'get accessor'.";
        public const string CS1546 = "CS1546. Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor method '{1}'.";
        public const string CS1547 = "CS1547. Keyword 'void' cannot be used in this context.";
        public const string CS1548 = "CS1548. Cryptographic failure while signing assembly '{0}' — '{1}'.";
        public const string CS1549 = "CS1549. Appropriate cryptographic service not found.";
        public const string CS1551 = "CS1551. Indexers must have at least one parameter.";
        public const string CS1552 = "CS1552. Array type specifier, [], must appear before parameter name.";
        public const string CS1553 = "CS1553. Declaration is not valid; use 'modifier operator <dest-type> (...' instead.";
        public const string CS1554 = "CS1554. Declaration is not valid; use '<type> operator op (...' instead.";
        public const string CS1555 = "CS1555. Could not find '{0}' for Main method in program '{1}'.";
        public const string CS1556 = "CS1556. '{0}' specified for Main method must be a valid class or struct.";
        public const string CS1557 = "CS1557. '{0}' specified for Main method not found in program '{1}', was found in '{2}'.";
        public const string CS1558 = "CS1558. '{0}' does not have a suitable Main method.";
        public const string CS1559 = "CS1559. '{0}' is imported and cannot be used as an entry point for program '{1}'.";
        public const string CS1560 = "CS1560. Filename specified for #line is too long.";
        public const string CS1562 = "CS1562. Outputs without source must have the /out option specified.";
        public const string CS1563 = "CS1563. Output '{0}' does not have any source files.";
        public const string CS1565 = "CS1565. Conflicting options specified: Win32 resource file; Win32 icon.";
        public const string CS1566 = "CS1566. Error reading resource file '{0}' — '{1}'.";
        public const string CS1567 = "CS1567. Error generating Win32 resource: '{0}',";
        public const string CS1569 = "CS1569. Error generating XML documentation file '{0}' ('{1}').";
        public const string CS1570 = "CS1570. XML comment on '{0}' has badly formed XML — '{1}'.";
        public const string CS1571 = "CS1571. XML comment on '{0}' has a duplicate param tag for '{1}'.";
        public const string CS1572 = "CS1572. XML comment on '{0}' has a param tag for '{1}', but there is no parameter by that name.";
        public const string CS1573 = "CS1573. Parameter '{0}' has no matching param tag in XML comment (but other parameters do).";
        public const string CS1574 = "CS1574. XML comment on '{0}' has cref attribute '{0}' that could not be found.";
        public const string CS1575 = "CS1575. A stackalloc expression requires [] after type.";
        public const string CS1576 = "CS1576. The line number specified for #line directive is missing or invalid.";
        public const string CS1577 = "CS1577. Assembly generation failed — '{0}'.";
        public const string CS1578 = "CS1578. Filename, single-line comment or end-of-line expected.";
        public const string CS1579 = "CS1579. foreach statement cannot operate on variables of type '{0}' because '{1}' does not contain a definition for '{2}', or it is inaccessible.";
        public const string CS1580 = "CS1580. Invalid type for parameter '{0}' in XML comment cref attribute.";
        public const string CS1581 = "CS1581. Invalid return type in XML comment cref attribute.";
        public const string CS1583 = "CS1583. '{0}' is not a valid Win32 resource file.";
        public const string CS1584 = "CS1584. XML comment on '{0}' has syntactically incorrect cref attribute '{1}'.";
        public const string CS1585 = "CS1585. Member modifier '{0}' must precede the member type and name.";
        public const string CS1586 = "CS1586. Array creation must have array size or array initializer.";
        public const string CS1587 = "CS1587. XML comment is not placed on a valid language element.";
        public const string CS1588 = "CS1588. Cannot determine common language runtime directory -- '{0}'.";
        public const string CS1589 = "CS1589. Unable to include XML fragment '{0}' of file '{1}' -- '{2}'.";
        public const string CS1590 = "CS1590. Invalid XML include element -- Missing file attribute.";
        public const string CS1591 = "CS1591. Missing XML comment for publicly visible type or member '{0}'.";
        public const string CS1592 = "CS1592. Badly formed XML in included comments file -- '{0}'.";
        public const string CS1593 = "CS1593. Delegate '{0}' does not take '{1}' arguments.";
        public const string CS1594 = "CS1594. Delegate '{0}' has some invalid arguments.";
        public const string CS1595 = "CS1595. '{0}' is defined in multiple places; using definition from '{1}'.";
        public const string CS1596 = "CS1596. XML documentation not updated during this incremental rebuild; use /incremental- to update XML documentation.";
        public const string CS1597 = "CS1597. Semicolon after method or accessor block is not valid.";
        public const string CS1598 = "CS1598. XML parser could be not be loaded for the following reason: '{0}'. The XML documentation file '{1}' will not be generated.";
        public const string CS1599 = "CS1599. Method or delegate cannot return type '{0}'.";
        public const string CS1600 = "CS1600. Compilation cancelled by user.";
        public const string CS1601 = "CS1601. Method or delegate parameter cannot be of type '{0}'.";
        public const string CS1602 = "CS1602. '{0}' is already defined in this assembly.";
        public const string CS1603 = "CS1603. Incremental build requires a target name specified with /out.";
        public const string CS1604 = "CS1604. Cannot assign to '{0}' because it is read-only.";
        public const string CS1605 = "CS1605. Cannot pass '{0}' as a ref or out argument because it is read-only.";
        public const string CS1606 = "CS1606. Assembly signing failed; output may not be signed -- '{0}'.";
        public const string CS1607 = "CS1607. Assembly generation -- '{0}'.";
        public const string CS1608 = "CS1608. The RequiredAttribute attribute is not permitted on C# types.";
        public const string CS1609 = "CS1609. Modifiers cannot be placed on property or event accessor declarations.";
        public const string CS1610 = "CS1610. Unable to delete temporary file '{0}' used for default Win32 resource -- '{1}'.";
        public const string CS1611 = "CS1611. The params parameter cannot be declared as ref or out.";
        public const string CS1612 = "CS1612. Cannot modify the return value of '{0}' because it is not a variable.";
        public const string CS1613 = "CS1613. The managed coclass wrapper class '{0}' for interface '{1}' is invalid or cannot be found (are you missing an assembly reference?).";
        public const string CS1614 = "CS1614. '{0}' is ambiguous; use either '@attribute' or 'attributeAttribute'.";
        public const string CS1618 = "CS1618. Cannot create delegate with '{0}' because it has a Conditional attribute.";
        public const string CS1619 = "CS1619. Cannot create temporary file '{0}' -- '{1}'.";
        public const string CS1900 = "CS1900. Warning level must be in the range 0-4.";
        public const string CS1901 = "CS1901. Conflicting options specified: Warning level 0; Treat warnings as errors.";
        public const string CS1902 = "CS1902. Invalid option 'option' for /debug; must be full or pdbonly.";
        public const string CS1904 = "CS1904. '{0}' is not a valid warning number.";
        public const string CS2000 = "CS2000. Compiler initialization failed unexpectedly.";
        public const string CS2001 = "CS2001. Source file '{0}' could not be found.";
        public const string CS2002 = "CS2002. Source file '{0}' specified multiple times.";
        public const string CS2003 = "CS2003. Response file '{0}' included multiple times.";
        public const string CS2005 = "CS2005. Missing file specification for '{0}' command-line option.";
        public const string CS2006 = "CS2006. Command-line syntax error: Missing '{0}' for '{1}' switch.";
        public const string CS2007 = "CS2007. Unrecognized command-line option: '{0}'.";
        public const string CS2008 = "CS2008. No inputs specified.";
        public const string CS2011 = "CS2011. Unable to open response file '{0}'.";
        public const string CS2012 = "CS2012. Can't open '{0}' for writing.";
        public const string CS2013 = "CS2013. Invalid image base number '{0}'.";
        public const string CS2014 = "CS2014. Compiler option '{0}' is obsolete, please use '{1}' instead.";
        public const string CS2015 = "CS2015. '{0}' is a binary file instead of a source code file.";
        public const string CS2016 = "CS2016. Code page '{0}' is invalid or not installed.";
        public const string CS2017 = "CS2017. Cannot specify /main if building a module or library.";
        public const string CS2018 = "CS2018. Unable to find messages file 'cscmsgs.dll'.";
        public const string CS2019 = "CS2019. Invalid target type for /target: must specify 'exe', 'winexe', 'library', or 'module'.";
        public const string CS2020 = "CS2020. Only the first set of input files can build a target other than '{0}'.";
        public const string CS2021 = "CS2021. File name '{0}' is too long or invalid.";
        public const string CS2022 = "CS2022. Options '/out' and '/target' must appear before source file names.";
        public const string CS2023 = "CS2023. Ignoring /noconfig option because it was specified in a response file.";
        public const string CS2024 = "CS2024. Invalid file section alignment number '#'.";
        public const string CS3001 = "CS3001. Argument type '{0}' is not CLS-compliant.";
        public const string CS3002 = "CS3002. Return type of '{0}' is not CLS-compliant.";
        public const string CS3003 = "CS3003. Type of '{0}' is not CLS-compliant.";
        public const string CS3004 = "CS3004. Mixed and decomposed Unicode characters are not CLS-compliant.";
        public const string CS3005 = "CS3005. Identifier '{0}' differing only in case is not CLS-compliant.";
        public const string CS3006 = "CS3006. Overloaded method '{0}' differing only in ref or out is not CLS-compliant.";
        public const string CS3008 = "CS3008. Identifier '{0}' is not CLS-compliant.";
        public const string CS3009 = "CS3009. '{0}': base type '{0}' is not CLS-compliant.";
        public const string CS3010 = "CS3010. '{0}': CLS-compliant interfaces must have CLS-compliant members.";
        public const string CS3011 = "CS3011. '{0}': only CLS-compliant members can be abstract.";
        public const string CS3012 = "CS3012. You must specify the CLSCompliant attribute on the assembly.";
        public const string CS3013 = "CS3013. Added module is not CLS-compliant, or is missing CLSCompliant attribute.";
        public const string CS3014 = "CS3014. '{0}' cannot be marked as CLS compliant because the assembly is not marked as compliant.";
        public const string CS3015 = "CS3015. '{0}' has no accessible constructors which use only CLS compliant types.";
        public const string CS3016 = "CS3016. Arrays as attribute arguments is not CLS-compliant.";
        public const string CS5000 = "CS5000. Unknown compiler option '/{0}'.";
        public const string CS5001 = "CS5001. Program '{0}' does not have an entry point defined.";
        public const string EXPECTED = "'{0}' expected but '{1}' found.";
        public const string PAS0001 = "PAS0001. Field or method identifier expected";
        public const string PAS0002 = "PAS0002. Incompatible types";
        public const string CSLite0001 = "CSLite0001. Module not found.";
        public const string CSLite0002 = "CSLite0002. Unknown language '{0}'.";
        public const string CSLite0003 = "CSLite0003. Cannot load compiled module '{0}' from '{1}'";
        public const string CSLite0004 = "CSLite0004. Incorrect scripter state. Expected '{0}'";
        public const string CSLite0005 = "CSLite0005. Error in Invoke. Method '{0}' not found.";
        public const string CSLite0006 = "CSLite0006. Use of forbidden namespace '{0}'.";
        public const string CSLite0007 = "CSLite0007. Use of forbidden type '{0}'.";
        public const string CSLite0008 = "CSLite0008. Current version of CSLiteScript does not support '{0}'.";
        public const string CSLite0009 = "CSLite0009. Error in RegisterInstance method. You have tried to register object which is not initialized.";
        public const string CSLite0010 = "CSLite0010. Error in RegisterInstance method. You have tried to register object which is already registered.";
        public const string SYNTAX_ERROR = "Syntax error.";
        public const string UNDECLARED_IDENTIFIER = "Undeclared identifier '{0}'";
        public const string VB00001 = "VB00001. Next control variable does not match For loop control variable '{0}'";
        public const string VB00002 = "VB00002. Explicit initialization is not permitted with multiple variables declared with a single type specifier.";
        public const string VB00003 = "VB00003. Arrays cannot be declared with 'New'";
        public const string VB00004 = "VB00004. Properties with no required parameters cannot be declared 'Default'.";
        public const string VB00005 = "VB00005. Delegate type not found";
        public const string VB00006 = "VB00006. Option Strict On requires all variable declarations to have an 'As' clause.";

        public static void RaiseException(string s)
        {
            throw new CSLiteScriptException(s);
        }

        public static void RaiseExceptionEx(string s, params object[] p)
        {
            throw new CSLiteScriptException(string.Format(s, p));
        }

        public class CSLiteScriptException : Exception
        {
            public CSLiteScriptException(string message) : base(message)
            {
            }
        }
    }
}

